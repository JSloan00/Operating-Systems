# Operating-Systems
# Briefly summarize The Gaming Room client and their software requirements. Who was the client? What type of software did they want you to design?
# My client, The Gaming Room, asked me to develop a web-based game that can be played on multiple platforms. The game, Draw It or Lose It, is currently available as an Android application. I was tasked to decide which operating system would be best to create this web-based game on. I created a technical design document to help myself and my client decide which operating system would be best. 

# What did you do particularly well in developing this documentation?
# I think I did particularly well in my explanations throughout the document. I did my best to explain each part and include all necessary information so that it was very easy to understand. Specifically, the recommendations section took me a lot of time doing research and putting everything into perspective for my client so that is easy for them to understand.

# What about the process of working through a design document did you find helpful when developing the code?
# The most helpful aspect of the design document was the design constraints section. This allowed me to look back at the document to keep in mind what the client specifically requires. The domain model was also very beneficial in developing code because I can see exactly how everything works together and develop my code based on the model. 

# If you could choose one part of your work on these documents to revise, what would you pick? How would you improve it?
# The one part that I would revise would be the recommendations section. Instead of listing Windows and Linux, I would choose to only recommend one operating system. I think the best OS to use for this task would be Linux, so I would give more information about this operating system instead of both. 

# How did you interpret the user’s needs and implement them into your software design? Why is it so important to consider the user’s needs when designing?
# 

# How did you approach designing software? What techniques or strategies would you use in the future to analyze and design a similar software application?
# 
